//-----------------------------------------------------------------------------
/*

MinBLEP testing

*/
//-----------------------------------------------------------------------------

package core

import (
	"math"
	"testing"
)

//-----------------------------------------------------------------------------
// Floating Point Comparisons
// See: http://floating-point-gui.de/errors/NearlyEqualsTest.java

const minNormal = 2.2250738585072014E-308 // 2**-1022

func equal(a, b, epsilon float64) bool {
	if a == b {
		return true
	}
	absA := math.Abs(a)
	absB := math.Abs(b)
	diff := math.Abs(a - b)
	if a == 0 || b == 0 || diff < minNormal {
		// a or b is zero or both are extremely close to it
		// relative error is less meaningful here
		return diff < (epsilon * minNormal)
	}
	// use relative error
	return diff/math.Min((absA+absB), math.MaxFloat64) < epsilon
}

//-----------------------------------------------------------------------------

func TestSinc(t *testing.T) {
	tests := []struct {
		x      float64
		result float64
	}{
		{0, 1},
		{1, 0},
		{-5, 0},
	}
	for _, v := range tests {
		y := Sinc(v.x)
		if !equal(y, v.result, 1e-15) {
			t.Logf("for x %f expected %f, actual %f\n", v.x, v.result, y)
			t.Error("FAIL")
		}
	}
}

//-----------------------------------------------------------------------------

func TestBlackman(t *testing.T) {
	w := []float64{
		-0.0000000149, 0.0037516505, 0.0156384222, 0.0374026746, 0.0714646131, 0.1202864647, 0.1856466979, 0.2679550052,
		0.3657350540, 0.4753785133, 0.5912286043, 0.7060008049, 0.8114932179, 0.8994904757, 0.9627307653, 0.9957970977,
		0.9957970381, 0.9627306461, 0.8994904757, 0.8114932775, 0.7060007453, 0.5912285447, 0.4753784239, 0.3657351434,
		0.2679550648, 0.1856467724, 0.1202863455, 0.0714645088, 0.0374026299, 0.0156384334, 0.0037516281, -0.0000000149,
	}
	n := len(w)
	y := BlackmanWindow(n)
	for i := 0; i < n; i++ {
		if !equal(y[i], w[i], 1e-4) {
			t.Logf("for i %d expected %.10f, actual %.10f\n", i, w[i], y[i])
			t.Error("FAIL")
		}
	}
}

//-----------------------------------------------------------------------------

func TestDFT(t *testing.T) {
	realTime := []float64{
		6.8037548065, -2.1123414040, 5.6619844437, 5.9688005447, 8.2329483032, -6.0489726067, -3.2955451012, 5.3645915985,
		-4.4445056915, 1.0793991089, -0.4520587921, 2.5774183273, -2.7043104172, 0.2680187225, 9.0445938110, 8.3239021301,
		2.7142343521, 4.3459396362, -7.1679487228, 2.1393775940, -9.6739883423, -5.1422648430, -7.2553682327, 6.0835342407,
		-6.8664178848, -1.9811124802, -7.4041910172, -7.8238239288, 9.9784889221, -5.6348619461, 0.2586479187, 6.7822437286,
	}
	imagTime := []float64{
		2.2527971268, -4.0793676376, 2.7510452271, 0.4857435226, -0.1283397675, 9.4555015564, -4.1496639252, 5.4271545410,
		0.5348987579, 5.3982772827, -1.9954280853, 7.8305892944, -4.3337054253, -2.9508328438, 6.1544914246, 8.3805294037,
		-8.6048946381, 8.9865417480, 0.5199069977, -8.2788829803, -6.1557230949, 3.2645378113, 7.8046531677, -3.0221414566,
		-8.7165737152, -9.5995388031, -0.8459653854, -8.7380828857, -5.2344007492, 9.4126815796, 8.0441627502, 7.0183963776,
	}
	realFreq := []float64{
		7.6201648712, 51.5333595276, 51.0579986572, -30.3952369690, -27.4529476166, -39.6588897705, -22.5868587494, -9.5177402496,
		25.4345283508, 54.9426193237, 20.4867820740, -43.5051345825, -51.4113006592, -46.2367668152, 23.5251655579, 80.3637237549,
		-20.7595443726, 9.4376277924, 27.9598865509, 5.8930711746, -22.6473445892, 15.3185234070, 14.3510484695, 3.5231218338,
		3.8653595448, 43.5667304993, -3.0527925491, -19.5659179688, 71.0071868896, 17.8246936798, 54.8900299072, -28.0915565491,
	}
	imagFreq := []float64{
		16.8883666992, -28.5795001984, 40.5040512085, -7.2958316803, 19.2130470276, -44.8562011719, 14.8515844345, -6.0897045135,
		-4.0269436836, 51.9030876160, -28.0184383392, 56.6038055420, -8.3701238632, 31.4415798187, -26.8036861420, 27.6120223999,
		-41.0938529968, 7.9510669708, 23.2380790710, 10.7462921143, -0.3470735550, 7.1576251984, -33.0806579590, 11.2359323502,
		-93.3114471436, 2.1925945282, 6.4554557800, -36.2122306824, -5.2225828171, 40.2756080627, 17.4901351929, 49.6368484497,
	}
	x, y := DFT(realTime, imagTime)
	n := len(realTime)
	for i := 0; i < n; i++ {
		if !equal(x[i], realFreq[i], 1e-4) {
			t.Logf("for i %d expected %.10f, actual %.10f\n", i, realFreq[i], x[i])
			t.Error("FAIL")
		}
		if !equal(y[i], imagFreq[i], 1e-4) {
			t.Logf("for i %d expected %.10f, actual %.10f\n", i, imagFreq[i], y[i])
			t.Error("FAIL")
		}
	}
}

//-----------------------------------------------------------------------------

func TestInverseDFT(t *testing.T) {
	realFreq := []float64{
		-4.6666851044, 0.7952070236, -2.4958605766, 5.2049741745, 0.2507076263, 3.3544750214, 0.6321287155, -9.2143936157,
		-1.2472476959, 8.6367015839, 8.6161956787, 4.4190464020, -4.3141317368, 4.7706871033, 2.7995767593, -2.9190263748,
		3.7572278976, -6.6805167198, -1.1979093552, 7.6015052795, 6.5840225220, -3.3932571411, -5.4206366539, 7.8674488068,
		-2.9927964211, 3.7333974838, 9.1293640137, 1.7728033066, 3.1460809708, 7.1735267639, -1.2088022232, 8.4793968201,
	}
	imagFreq := []float64{
		-2.0312666893, 6.2953376770, 3.6843700409, 8.2194404602, -0.3501873016, -5.6835007668, 9.0050468445, 8.4025650024,
		-7.0467996597, 7.6212425232, 2.8216123581, -1.3609313965, 2.3919296265, -4.3788118362, 5.7200422287, -3.8508424759,
		-1.0593280792, -5.4778676033, -6.2493376732, -4.4753065109, 1.1288747787, -1.6699743271, -6.6078581810, 8.1360778809,
		-7.9365763664, -7.4784932137, -0.0911188126, 5.2095041275, 9.6950321198, 8.7000808716, 3.6888999939, -2.3362331390,
	}
	realTime := []float64{
		1.6554127932, -0.5607256889, 0.3516451716, 0.6006245613, -0.4479787350, -1.4550230503, -1.1336766481, -0.1594698876,
		0.3024804890, -0.2617984712, 0.3744757175, -0.3259984255, -0.2825476825, -1.0880458355, -0.6885758638, -0.5689893365,
		-0.9447128773, -1.0887057781, 0.4416206479, -1.4870239496, 0.4995092154, 0.6932485104, 1.8445467949, -1.8562583923,
		-0.9485384822, 1.6228623390, 0.6621118784, 0.9472764730, -1.1209881306, -0.1902397871, -1.0195093155, 0.9663084745,
	}
	imagTime := []float64{
		-0.7073633671, -1.2149522305, 0.9092290401, 0.2527691722, 0.0717095584, 1.0751802921, 1.7911074162, -0.5573069453,
		0.6875460744, 0.6371049285, -1.1339958906, -0.0402838588, 1.4481706619, 0.2926798761, -0.8165590763, 0.7310736775,
		0.2846530080, 0.3740379214, -0.9991326332, 1.3043708801, 0.7839231491, -2.0440754890, -0.7289658785, 0.2355433404,
		0.3862025142, 0.8115178943, -1.2630518675, 0.5567849874, 1.5636579990, -0.1248829290, -0.7318258286, -1.8035911322,
	}
	x, y := InverseDFT(realFreq, imagFreq)
	n := len(realFreq)
	for i := 0; i < n; i++ {
		if !equal(x[i], realTime[i], 1e-4) {
			t.Logf("for i %d expected %.10f, actual %.10f\n", i, realTime[i], x[i])
			t.Error("FAIL")
		}
		if !equal(y[i], imagTime[i], 1e-4) {
			t.Logf("for i %d expected %.10f, actual %.10f\n", i, imagTime[i], y[i])
			t.Error("FAIL")
		}
	}
}

//-----------------------------------------------------------------------------

func TestRealCepstrum(t *testing.T) {
	signal := []float64{
		4.9954175949, -2.6267290115, -4.1167926788, -5.3547692299, 1.6897697449, -5.1117453575, -6.9522042274, 4.6429710388,
		-7.4905018806, 5.8694076538, -6.7179613113, 4.9014282227, -8.5094041824, 9.0020809174, -8.9494152069, 0.4312667847,
		-6.4757871628, -5.1987524033, 5.9559612274, 4.6530876160, 3.1312732697, 9.3481025696, 2.7891674042, 5.1946973801,
		-8.1303901672, -7.3019514084, 0.4042015076, -8.4353570938, -8.6018714905, -5.9068984985, -0.7715902328, 6.3935451508,
	}
	realCepstrum := []float64{
		3.3238639832, -0.0374856517, 0.2131541669, -0.0891583487, 0.0140011907, 0.0095269009, -0.0811940506, -0.1136711314,
		0.0090116728, 0.0296635590, 0.0816734433, 0.0291559435, 0.0220543891, 0.1289931834, 0.0226377547, -0.0687999949,
		-0.0453420207, -0.0687998161, 0.0226387829, 0.1289935112, 0.0220549479, 0.0291553997, 0.0816737562, 0.0296620764,
		0.0090132235, -0.1136698127, -0.0811936706, 0.0095268637, 0.0140006952, -0.0891596004, 0.2131514251, -0.0374885201,
	}
	x := RealCepstrum(signal)
	n := len(signal)
	for i := 0; i < n; i++ {
		if !equal(x[i], realCepstrum[i], 1e-4) {
			t.Logf("for i %d expected %.10f, actual %.10f\n", i, realCepstrum[i], x[i])
			t.Error("FAIL")
		}
	}
}

//-----------------------------------------------------------------------------

func TestMinBLEP(t *testing.T) {
	minBLEP := []float64{
		-0.0023816479, -0.0005826617, 0.0119837150, 0.0467668399, 0.1200100183, 0.2479422688, 0.4375963807, 0.6774262190,
		0.9339594245, 1.1589831114, 1.3063800335, 1.3515392542, 1.3032937050, 1.2011421919, 1.0980731249, 1.0373778343,
		1.0353800058, 1.0786098242, 1.1356719732, 1.1760005951, 1.1847332716, 1.1665102243, 1.1382699013, 1.1172436476,
		1.1117588282, 1.1191105843, 1.1296629906, 1.1331173182, 1.1230788231, 1.0985108614, 1.0630007982, 1.0233261585,
		0.9878786206, 0.9646015763, 0.9583041668, 0.9683063030, 0.9880650640, 1.0077186823, 1.0186288357, 1.0174398422,
		1.0072134733, 0.9949913621, 0.9874276519, 0.9872575402, 0.9925978184, 0.9990452528, 1.0027939081, 1.0026539564,
		1.0000000000,
	}
	x := GenerateMinBLEP(6, 4)
	n := len(minBLEP)
	for i := 0; i < n; i++ {
		if !equal(x[i], minBLEP[i], 1e-4) {
			t.Logf("for i %d expected %.10f, actual %.10f\n", i, minBLEP[i], x[i])
			t.Error("FAIL")
		}
	}
}

//-----------------------------------------------------------------------------
